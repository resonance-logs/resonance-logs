version: 2.1

orbs:
  win: circleci/windows@5.1.1

jobs:
  build-tauri:
    executor:
      name: win/default
      shell: powershell.exe
    environment:
      CARGO_HOME: C:\cargo
      npm_config_cache: C:\npm
    steps:
      - add_ssh_keys:
          fingerprints:
            - "SHA256:9oEjBSJ+yaAdwWFA2OKShvDSDU/m5VIHwKwJMSaNglw"
      - checkout

      # Node is already installed in the CI environment — do NOT install via choco here.
      # The installation step is commented out to avoid mixing multiple Node installs.
      # - run: choco install nodejs-lts -y
      # - run: refreshenv

      # Install Rust
      - run: |
          Invoke-WebRequest -Uri https://win.rustup.rs/x86_64 -OutFile rustup-init.exe
          .\rustup-init.exe -y --default-toolchain stable --profile minimal
          Remove-Item rustup-init.exe
          echo "PATH=C:\cargo\bin;$env:PATH" | Out-File $env:USERPROFILE\cargo_path.txt

      - run: |
          setx PATH "$(Get-Content "$env:USERPROFILE\cargo_path.txt")"

      # Verify Node/npm versions immediately after install for better diagnostics
      - run: node --version
      - run: npm --version
      - run: rustc --version
      - run: cargo --version

      # Install Visual C++ Build Tools (MSVC) and ensure Rust uses the MSVC toolchain.
      # This provides the Microsoft toolchain (link.exe) required by many crates.
      - run: |
          Write-Host "Installing Visual Studio Build Tools (MSVC) via Chocolatey"
          choco install visualstudio2022buildtools --package-parameters "--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended --passive --norestart" -y

          # Ensure vswhere exists and can be used to locate vcvarsall.bat later
          $vswhere = "$env:ProgramFiles(x86)\Microsoft Visual Studio\Installer\vswhere.exe"
          if (-not (Test-Path $vswhere)) {
            Write-Host "vswhere not found at $vswhere — attempting to install vswhere"
            choco install vswhere -y
          }

          # Install the MSVC Rust toolchain to match MSVC build environment
          Write-Host "Installing Rust MSVC toolchain"
          & rustup toolchain install stable-x86_64-pc-windows-msvc
          if ($LASTEXITCODE -ne 0) { Write-Host "rustup toolchain install returned non-zero" }
          & rustup default stable-x86_64-pc-windows-msvc
          if ($LASTEXITCODE -ne 0) { Write-Host "rustup default returned non-zero" }

      # Install dependencies with verbose output to capture useful errors on failure
      # Also perform diagnostics to detect multiple Node/npm installations and
      # fallback to the npm bundled with the installed Node if necessary.
      - run: |
          Write-Host "Running npm install (verbose) with diagnostics"
          Write-Host "PATH=$env:PATH"
          Write-Host "----- where.exe node -----"
          $whereNode = & where.exe node 2>$null
          if (-not $whereNode) { Write-Host "where.exe node returned no results" } else { Write-Host $whereNode }
          Write-Host "----- where.exe npm -----"
          $whereNpm = & where.exe npm 2>$null
          if (-not $whereNpm) { Write-Host "where.exe npm returned no results" } else { Write-Host $whereNpm }
          Write-Host "----- Get-Command node/npm -----"
          Get-Command node | Format-List -Property Path,Version -Force
          Get-Command npm  | Format-List -Property Path -Force
          node --version
          npm --version

          # Prefer using the npm that ships with the installed Node to avoid mixing
          # different installations that can cause 'Class extends value undefined' errors.
          $nodeBundledNpm = "$env:ProgramFiles\nodejs\node_modules\npm\bin\npm-cli.js"
          if (Test-Path $nodeBundledNpm) {
            Write-Host "Found node-bundled npm at: $nodeBundledNpm — invoking it via node"
            node $nodeBundledNpm install --verbose --no-audit --no-fund
          } else {
            Write-Host "Node-bundled npm not found, falling back to npm from PATH"
            npm install --verbose --no-audit --no-fund
          }

      # Create changelog-like text
      - run: |
          $msg = git log -1 --pretty=%B
          $body = "# Changelog`n$msg"
          Out-File release_body.txt -InputObject $body -Encoding utf8

      # Build release or debug depending on tag. If Visual Studio Build Tools are installed,
      # source vcvarsall.bat to set MSVC environment for the build.
      - run: |
          $buildCmd = if ($env:CIRCLE_TAG) { 'npm run tauri build' } else { 'npm run tauri build -- --debug' }

          $vswhere = "$env:ProgramFiles(x86)\Microsoft Visual Studio\Installer\vswhere.exe"
          if (Test-Path $vswhere) {
            $vsPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
            if ($vsPath) {
              $vcvars = Join-Path $vsPath 'VC\Auxiliary\Build\vcvarsall.bat'
              if (Test-Path $vcvars) {
                Write-Host "Sourcing vcvarsall and running build via cmd to pick up MSVC environment"
                cmd /c "`"$vcvars`" x64 && $buildCmd"
              } else {
                Write-Host "vcvarsall not found at $vcvars — running build without sourcing vcvarsall"
                iex $buildCmd
              }
            } else {
              Write-Host "vswhere couldn't find Visual Studio installation — running build without vcvarsall"
              iex $buildCmd
            }
          } else {
            Write-Host "vswhere not present at $vswhere — running build without vcvarsall"
            iex $buildCmd
          }

      # Persist results
      - store_artifacts:
          path: src-tauri/target
          destination: tauri-target
      - store_artifacts:
          path: release_body.txt

      - persist_to_workspace:
          root: .
          paths:
            - src-tauri/target
            - release_body.txt


  create-gitlab-release:
    docker:
      - image: cimg/base:stable
    steps:
      - add_ssh_keys:
          fingerprints:
            - "SHA256:9oEjBSJ+yaAdwWFA2OKShvDSDU/m5VIHwKwJMSaNglw"
      - checkout
      - attach_workspace:
          at: .

      - run:
          name: Create GitLab Release + Upload Assets
          command: |
            set -e

            # Read from CircleCI env vars
            PROJECT_ID="${GITLAB_PROJECT_ID}"
            RELEASE_TAG="$CIRCLE_TAG"
            RELEASE_NAME="Release $RELEASE_TAG"
            RELEASE_NOTES="$(cat release_body.txt)"

            if [ -z "$PROJECT_ID" ]; then
              echo "❌ ERROR: GITLAB_PROJECT_ID environment variable not set."
              exit 1
            fi
            if [ -z "$GITLAB_TOKEN" ]; then
              echo "❌ ERROR: GITLAB_TOKEN environment variable not set."
              exit 1
            fi

            echo "Creating GitLab Release for tag: $RELEASE_TAG"
            echo "Using Project ID: $PROJECT_ID"

            # ---------------------------------------------------
            # Step 1 — Create/update the release record
            # ---------------------------------------------------
            curl --request POST \
              --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
              "https://gitlab.com/api/v4/projects/$PROJECT_ID/releases" \
              --form "tag_name=$RELEASE_TAG" \
              --form "name=$RELEASE_NAME" \
              --form "description=$RELEASE_NOTES" \
              || echo "Release may already exist, continuing…"

            echo ""
            echo "Looking for Windows installer files…"

            # Find all .exe installers inside your tauri build output
            mapfile -t FILES < <(find src-tauri/target -type f -iname "*.exe")

            if [ ${#FILES[@]} -eq 0 ]; then
              echo "⚠️  No installer binaries found in src-tauri/target"
            fi

            for FILE in "${FILES[@]}"; do
              echo "Uploading: $FILE"

              # ---------------------------------------------------
              # Step 2 — Upload to GitLab
              # ---------------------------------------------------
              UPLOAD_RESPONSE=$(curl --silent --request POST \
                --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
                --form "file=@${FILE}" \
                "https://gitlab.com/api/v4/projects/$PROJECT_ID/uploads")

              echo "Upload response: $UPLOAD_RESPONSE"

              ASSET_URL=$(echo "$UPLOAD_RESPONSE" | jq -r '.url')

              if [[ "$ASSET_URL" == "null" ]]; then
                echo "❌ Upload failed for $FILE"
                continue
              fi

              BASENAME=$(basename "$FILE")
              FULL_URL="https://gitlab.com/$ASSET_URL"

              echo "Attaching asset link for $BASENAME → $FULL_URL"

              # ---------------------------------------------------
              # Step 3 — Attach uploaded file to release
              # ---------------------------------------------------
              curl --request POST \
                --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
                "https://gitlab.com/api/v4/projects/$PROJECT_ID/releases/$RELEASE_TAG/assets/links" \
                --form "name=$BASENAME" \
                --form "url=$FULL_URL" \
                --form "link_type=other"
            done

            echo "✅ GitLab Release complete with attached assets!"


  pages:
    docker:
      - image: alpine:3.18
    steps:
      - add_ssh_keys:
          fingerprints:
            - "SHA256:9oEjBSJ+yaAdwWFA2OKShvDSDU/m5VIHwKwJMSaNglw"
      - checkout
      - attach_workspace:
          at: .

      - run: apk add curl unzip coreutils bash

      - run:
          name: Build public directory
          command: |
            mkdir deploy

            # Copy static public/
            if [ -d public ]; then
              cp -r public/* deploy/
            fi

            # Add installers to /downloads
            mkdir -p deploy/downloads
            find src-tauri/target -type f -name "*.exe" -exec cp {} deploy/downloads/ \; || true

            # Generate manifest.json
            cd deploy/downloads
            set -- *.exe
            if [ -e "$1" ]; then
              echo '{' > manifest.json
              echo '  "versions": [' >> manifest.json
              first=1
              for f in "$@"; do
                if [ $first -eq 1 ]; then first=0; else echo ',' >> manifest.json; fi
                printf '    { "filename": "%s" }' "$f" >> manifest.json
              done
              echo '' >> manifest.json
              echo '  ],' >> manifest.json
              latest=$(ls -1t -- *.exe | head -n1)
              echo "  \"latest\": \"$latest\"" >> manifest.json
              echo '}' >> manifest.json
            fi
            cd -

            mv deploy public

      - store_artifacts:
          path: public
          destination: pages


workflows:

  build_and_release:
    jobs:
      - build-tauri:
          filters:
            tags:
              only: /.*/
            branches:
              ignore: /.*/

      - create-gitlab-release:
          requires:
            - build-tauri
          filters:
            tags:
              only: /.*/
            branches:
              ignore: /.*/

      - pages:
          requires:
            - build-tauri
          filters:
            tags:
              only: /.*/
            branches:
              ignore: /.*/
