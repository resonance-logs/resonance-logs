# Blueprotobuf Lib

The `blueprotobuf-lib` module is a critical component of the Resonance Logs backend, responsible for decoding the game's network protocol. The game uses [Protocol Buffers (Protobuf)](https://developers.google.com/protocol-buffers), a binary serialization format developed by Google, to structure its network messages. This module contains the necessary logic to parse these binary messages and convert them into structured, usable Rust objects.

## Protobuf Definitions

The core of this module is the set of `.proto` files that define the structure of the game's network messages. These files are not included in the source code but are used during the build process to generate the corresponding Rust code. The generated code provides the structs and enums that represent the various messages and data types used by the game.

## Code Generation: `build.rs`

The magic of converting the `.proto` definitions into Rust code happens in the `build.rs` script located in the `src-tauri/src/blueprotobuf-lib` directory. This script is executed by Cargo before compiling the rest of the crate.

It uses two key build-time dependencies:

1.  **`prost-build`**: This is the primary tool for compiling `.proto` files into Rust code. It generates the structs, enums, and the necessary methods for encoding and decoding the protobuf messages.
2.  **`pbjson-build`**: This tool is used to generate serialization and deserialization implementations for `serde`. This allows the generated Rust structs to be easily converted to and from JSON, which is useful for debugging, logging, and potentially for sending data to the frontend in a human-readable format.

The `build.rs` script looks for all `.proto` files in a specified directory and invokes `prost-build` and `pbjson-build` to generate the corresponding `.rs` files. These generated files are then included in the main library file (`lib.rs`) using the `include!` macro.

## Library Entry Point: `lib.rs`

The `src-tauri/src/blueprotobuf-lib/src/lib.rs` file is the main entry point for the compiled crate. It does two things:

1.  **Includes Generated Code**: It uses `include!` macros to include the Rust code generated by `prost-build` and `pbjson-build`. The paths to these files are determined by the `OUT_DIR` environment variable, which is set by Cargo during the build process. This makes the generated structs and enums available to the rest of the application under the `blueprotobuf::blueprotobuf` module path.
2.  **Implements `From<i64>` for `EEntityType`**: It provides a custom implementation of the `From` trait to convert a raw `i64` entity type from the game's protocol into the `EEntityType` enum. This is a good example of how to extend the generated code with custom logic to make it more ergonomic to use.

## Usage in the Application

The `live` module, specifically in `live_main.rs`, makes extensive use of the `blueprotobuf-lib`. When the `live` module receives a raw game packet from the `packets` module, it uses the `decode` method (provided by `prost`) on the appropriate struct from `blueprotobuf-lib` to parse the binary data.

For example, when an `EnterScene` packet is received, the `live` module calls `blueprotobuf::EnterScene::decode(data)`. If the decoding is successful, it returns an `EnterScene` struct, which contains all the fields defined in the corresponding `.proto` file. This structured data can then be easily used to update the application's state.

By encapsulating the protocol decoding logic in this separate library, the rest of the application is shielded from the complexities of the binary protocol, leading to cleaner, more maintainable code.
